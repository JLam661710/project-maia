# 交互体验优化规划 v2 (修正版)：并行流水线模式

## 1. 核心纠正 (Correction)
非常抱歉之前的理解有误。我已完全理解你的意思：**我们依然保持严格的“一问一答”回合制**，只是将“用户打字时间”与“后台分析时间”进行**重叠 (Overlapping)**，以消除无效等待。

**不是**让用户发多条，而是让用户**不用等后台跑完就能开始回单条消息**。

## 2. 修正后的逻辑流程 (Revised Logic)

我们将采用 **“异步并行 + 栅栏等待 (Barrier Synchronization)”** 模式：

1.  **Interviewer 回复**：Maia 说完话。
2.  **并行启动 (Parallel Start)**：
    *   **轨道 A (后台)**：启动 Analyst/Judge 进行复盘分析（耗时约 5-10s）。
    *   **轨道 B (前台)**：**立即解锁输入**，允许用户输入**一条**消息。
3.  **汇合点 (Rendezvous Point)**：
    *   **情况 1：用户手速快 (User is Fast)**
        *   用户在 3秒 时输入了内容并回车。
        *   此时 Analyst 还在跑。
        *   系统将用户输入**存入暂存区**。
        *   UI 提示：`[System] 输入已接收，正在等待后台分析同步...`
        *   等 Analyst 跑完 (10s) -> 立即触发 Interviewer 回复。
    *   **情况 2：用户思考慢 (User is Slow)**
        *   Analyst 在 10s 时跑完了。
        *   用户还在思考。
        *   系统**静默更新**后台状态（用户无感知）。
        *   用户在 20s 时输入内容 -> 立即触发 Interviewer 回复（毫秒级响应）。

## 3. 实现方案 (`main.py`)

我将引入 Python 的 `asyncio.create_task` 来实现这种并行控制：

1.  **循环结构调整**：
    *   每一轮 Maia 回复后，创建一个后台任务 `analyst_task`。
    *   立即进入 `input()` 等待。
2.  **输入处理**：
    *   当获得 `user_input` 后，检查 `analyst_task` 是否完成。
    *   如果没完成，使用 `await analyst_task` 等待它结束（这就是你提到的“暂存队列”效果，实际上是在内存中挂起等待）。
    *   如果已完成，直接继续。

## 4. 最终确认
这个方案既保证了**每一轮只能发一条**的严格节奏，又完美利用了后台分析的时间窗口，消除了用户的等待焦虑。

如果确认这个逻辑符合你的设想，我将立即开始代码修改。
